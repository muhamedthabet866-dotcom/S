import streamlit as st
import pandas as pd
import requests
from io import BytesIO
import re

st.set_page_config(page_title="MBA SPSS Solver Ultimate", layout="wide")

st.title("ğŸ“ Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„ - Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ Ù…Ø­Ù…Ø¯")

# Ø¯Ø§Ù„Ø© Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ ØªÙ…Ø§Ù…Ø§Ù‹ Ù…Ù† Ø£ÙŠ Ù…Ø³Ø§ÙØ§Øª Ø£Ùˆ Ø±Ù…ÙˆØ² ØªØ´ØªÙŠØª
def clean_text(text):
    if not text: return ""
    # ØªØ­ÙˆÙŠÙ„ Ù„ØµØºÙŠØ± + Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ±Ù‚ÙŠÙ… + ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù…Ø³Ø§ÙØ© ÙˆØ§Ø­Ø¯Ø©
    text = text.lower()
    text = re.sub(r'[^\w\s]', ' ', text)
    return " ".join(text.split())

# --- Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†Ù‡Ø¬ Ù…Ù† GitHub ---
GITHUB_URL = "https://github.com/muhamedthabet866-dotcom/S/raw/refs/heads/main/spss_rules.xlsx"

@st.cache_data
def load_rules(url):
    try:
        res = requests.get(url, timeout=10)
        return pd.read_excel(BytesIO(res.content))
    except: return None

rules_df = load_rules(GITHUB_URL)

# --- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ---
with st.sidebar:
    st.header("ğŸ“Š 1. Ù…Ù„Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
    data_file = st.file_uploader("Ø§Ø±ÙØ¹ Ù…Ù„Ù Ø§Ù„Ø¥ÙƒØ³ÙŠÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ", type=['xlsx', 'xls'])
    if data_file:
        df_data = pd.read_excel(data_file)
        st.write("Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…ÙƒØªØ´ÙØ©:", list(df_data.columns))

    st.header("âš™ï¸ 2. ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª")
    mapping_input = st.text_area("Ø§Ù„ØªØ¹Ø±ÙŠÙ (X1=Name):", 
        value="X1=account balance\nX2=ATM transactions\nX4=debit card\nX5=interest\nX6=city", height=200)

st.header("ğŸ“ 3. Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø§Ù…ØªØ­Ø§Ù†")
questions_input = st.text_area("Ø§Ù„ØµÙ‚ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ù‡Ù†Ø§:", height=300)

if st.button("ğŸš€ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ SPSS Syntax"):
    if rules_df is not None and questions_input:
        # 1. ØªØ­Ø¶ÙŠØ± Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ù†Ø¸Ù
        mapping = {}
        for line in mapping_input.split('\n'):
            if '=' in line:
                parts = line.split('=')
                mapping[clean_text(parts[1])] = parts[0].strip().upper()
        
        sorted_keys = sorted(mapping.keys(), key=len, reverse=True)

        final_syntax = ["* Generated by MBA Solver.\nSET DECIMALS=DOT.\n"]

        # 2. Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
        for q in questions_input.split('\n'):
            if len(q.strip()) < 5: continue
            
            q_clean = clean_text(q)
            matched = False
            
            # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ù†Ù‡Ø¬ (Ø§Ù„Ù…Ù†Ø¸Ù)
            for _, rule in rules_df.iterrows():
                keyword = clean_text(str(rule['Keyword']))
                
                if keyword in q_clean:
                    template = str(rule['Syntax_Template'])
                    
                    # Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙƒÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø°ÙƒÙˆØ±Ø© ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø±
                    found = []
                    for k in sorted_keys:
                        if k in q_clean:
                            found.append(mapping[k])
                    
                    if found:
                        # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø± Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØ±ØªÙŠØ¨
                        vars_only = list(dict.fromkeys(found))
                        syntax = template.replace("{var}", " ".join(vars_only))
                        
                        # Ù…Ù†Ø·Ù‚ Ø§Ù„Ù€ BY (Ù…ØªØºÙŠØ± Ø§Ù„ØªÙ‚Ø³ÙŠÙ…) - Ù†Ø£Ø®Ø° Ø§Ù„Ù…ØªØºÙŠØ± Ø§Ù„Ø£Ø®ÙŠØ± ØºØ§Ù„Ø¨Ø§Ù‹
                        if "{group}" in syntax:
                            group = vars_only[-1] if len(vars_only) > 1 else vars_only[0]
                            syntax = syntax.replace("{group}", group)
                        
                        final_syntax.append(f"* Question: {q.strip()}\n{syntax}\nEXECUTE.")
                        matched = True
                        break
            
            if not matched:
                final_syntax.append(f"* Question: {q.strip()}\n* [!] Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù‚Ø§Ø¹Ø¯Ø©.")

        st.code("\n".join(final_syntax), language="spss")
    else:
        st.error("ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ù„Ù Ø§Ù„Ù…Ù†Ù‡Ø¬ ÙˆØ§Ù„Ø£Ø³Ø¦Ù„Ø©.")
