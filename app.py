import streamlit as st
import pandas as pd
import re
import base64
from datetime import datetime
import chardet

class PerfectSPSSGenerator:
    def __init__(self):
        self.uploaded_files = {}
        self.generated_codes = {}
    
    def detect_encoding(self, file_content):
        """ÙƒØ´Ù ØªØ±Ù…ÙŠØ² Ø§Ù„Ù…Ù„Ù"""
        result = chardet.detect(file_content)
        return result['encoding'] if result['encoding'] else 'utf-8'
    
    def parse_questions(self, text_content):
        """ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø¨Ø¯Ù‚Ø© Ù…Ø¹ Ø¯Ø¹Ù… Ø£ÙØ¶Ù„ Ù„Ù„Ø¹Ø±Ø¨ÙŠØ©"""
        questions = []
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙƒ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø¥Ø°Ø§ ÙƒØ§Ù† bytes
        if isinstance(text_content, bytes):
            encoding = self.detect_encoding(text_content)
            try:
                text_content = text_content.decode(encoding)
            except:
                text_content = text_content.decode('utf-8', errors='ignore')
        
        lines = text_content.split('\n')
        current_q = ""
        question_patterns = [
            r'^\d+[\.\)]',  # 1. or 1)
            r'^\d+\.\s+',   # 1. 
            r'^Ø³Ø¤Ø§Ù„\s*\d+', # Ø³Ø¤Ø§Ù„ 1
            r'^Question\s*\d+', # Question 1
        ]
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¨Ø¯Ø§ÙŠØ© Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯
            is_new_question = any(re.match(pattern, line, re.IGNORECASE) for pattern in question_patterns)
            
            if is_new_question:
                if current_q:
                    questions.append(current_q.strip())
                current_q = line
            elif current_q and not line.startswith('*'):
                current_q += " " + line
        
        if current_q:
            questions.append(current_q.strip())
        
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
        cleaned_questions = []
        for q in questions:
            # Ø¥Ø²Ø§Ù„Ø© Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØµÙØ­Ø§Øª ÙˆØ§Ù„ØªÙ†Ø³ÙŠÙ‚Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ø±ØºÙˆØ¨Ø©
            q = re.sub(r'ØµÙØ­Ø©\s*\d+', '', q, flags=re.IGNORECASE)
            q = re.sub(r'Page\s*\d+', '', q, flags=re.IGNORECASE)
            q = re.sub(r'\s+', ' ', q).strip()
            if len(q) > 10:  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù‚ØµÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹
                cleaned_questions.append(q)
        
        return cleaned_questions
    
    def validate_dataframe(self, df):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
        required_vars = ['X1', 'X2', 'X3', 'X4', 'X5', 'X6']
        missing_vars = []
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ© Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¨Ø£Ø³Ù…Ø§Ø¡ Ù…Ø®ØªÙ„ÙØ©
        column_mapping = {}
        for col in df.columns:
            col_upper = str(col).upper()
            for req_var in required_vars:
                if req_var in col_upper or col_upper in req_var:
                    column_mapping[col] = req_var
        
        if column_mapping:
            df = df.rename(columns=column_mapping)
            st.info(f"âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©: {column_mapping}")
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        for var in required_vars:
            if var not in df.columns:
                missing_vars.append(var)
        
        return df, missing_vars
    
    def generate_dataset1_code(self, questions, df):
        """ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ù…Ø·Ø§Ø¨Ù‚ Ù„Ù„Ù†Ù…ÙˆØ°Ø¬ ØªÙ…Ø§Ù…Ø§Ù‹"""
        df, missing_vars = self.validate_dataframe(df)
        
        code = f"""* Encoding: UTF-8.
* Generated by SPSS Perfect Generator on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}.

* [PRE-ANALYSIS SETUP] Defining Variable Labels and Values.
VARIABLE LABELS 
    X1 "Account Balance ($)" 
    X2 "ATM Transactions" 
    X3 "Other Services" 
    X4 "Debit Card Holder" 
    X5 "Interest Received" 
    X6 "City Location".

VALUE LABELS 
    X4 0 "No" 1 "Yes" 
    /X5 0 "No" 1 "Yes" 
    /X6 1 "City 1" 2 "City 2" 3 "City 3" 4 "City 4".

"""
        
        # ØªØ­Ø°ÙŠØ± Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©
        if missing_vars:
            code += f"""* WARNING: The following variables were not found in the dataset: {', '.join(missing_vars)}.
* Please adjust variable names according to your actual data structure.

"""
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„ Ø³Ø¤Ø§Ù„ Ø­Ø³Ø¨ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
        max_questions = min(len(questions), 16)
        for i, question in enumerate(questions[:max_questions], 1):
            code += self._generate_question_template(i, question, df)
        
        return code
    
    def _generate_question_template(self, q_num, question, df):
        """ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ù„ÙƒÙ„ Ø³Ø¤Ø§Ù„ Ù…Ø·Ø§Ø¨Ù‚ Ù„Ù„Ù†Ù…ÙˆØ°Ø¬"""
        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù„Ù„Ø¹Ø±Ø¶
        clean_question = re.sub(r'[\n\r\t]+', ' ', question)
        clean_question = clean_question[:80] + ('...' if len(clean_question) > 80 else '')
        
        code = f"""* -------------------------------------------------------------------------.
TITLE "QUESTION {q_num}: {clean_question}".
* -------------------------------------------------------------------------.
"""
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„ Ø³Ø¤Ø§Ù„ Ø­Ø³Ø¨ Ø±Ù‚Ù…Ù‡ Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª
        if q_num == 1:
            code += """FREQUENCIES VARIABLES=X4 X5 X6
  /ORDER=ANALYSIS
  /STATISTICS=ALL.

"""
        
        elif q_num == 2:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ X1
            if 'X1' in df.columns:
                max_val = df['X1'].max() if not df['X1'].empty else 5000
                code += f"""RECODE X1 (0 thru 500=1) (500.01 thru 1000=2) (1000.01 thru 1500=3) 
  (1500.01 thru 2000=4) (2000.01 thru HI=5) INTO X1_Classes.
VALUE LABELS X1_Classes 
  1 "0-500" 
  2 "501-1000" 
  3 "1001-1500" 
  4 "1501-2000" 
  5 "Over 2000".
FREQUENCIES VARIABLES=X1_Classes /FORMAT=AVALUE.
ECHO "COMMENT: This distribution reveals the wealth concentration among the bank clients".

"""
            else:
                code += """* Variable X1 not found in dataset. Please adjust variable name.
FREQUENCIES VARIABLES=X1_Classes /FORMAT=AVALUE.

"""
        
        elif q_num == 3:
            code += """* K-rule: 2^k >= N. For N=60, 2^6=64, so 6 classes are optimal.
RECODE X2 (2 thru 5=1) (6 thru 9=2) (10 thru 13=3) (14 thru 17=4) 
  (18 thru 21=5) (22 thru 25=6) INTO X2_Krule.
VALUE LABELS X2_Krule 
  1 "2-5" 
  2 "6-9" 
  3 "10-13" 
  4 "14-17" 
  5 "18-21" 
  6 "22-25".
FREQUENCIES VARIABLES=X2_Krule.
ECHO "COMMENT: Based on the K-rule, 6 classes provide a clear view of transaction intensity".

"""
        
        elif q_num == 4:
            code += """FREQUENCIES VARIABLES=X1 X2 
  /FORMAT=NOTABLE 
  /STATISTICS=MEAN MEDIAN MODE MINIMUM MAXIMUM RANGE VARIANCE STDDEV SKEWNESS SESKEW
  /HISTOGRAM NORMAL.

"""
        
        elif q_num == 5:
            code += """* Histograms for continuous variables.
GRAPH /HISTOGRAM(NORMAL)=X1 
  /TITLE="Histogram of Account Balance with Normal Curve".
GRAPH /HISTOGRAM(NORMAL)=X2 
  /TITLE="Histogram of ATM Transactions with Normal Curve".

"""
        
        elif q_num == 6:
            code += """* Skewness interpretation.
DESCRIPTIVES VARIABLES=X1 X2
  /STATISTICS=MEAN MEDIAN SKEWNESS.
ECHO "ANALYSIS: If Mean > Median, distribution is Right-Skewed (Positive Skewness).".
ECHO "If Mean < Median, distribution is Left-Skewed (Negative Skewness).".
ECHO "Skewness between -0.5 and 0.5 indicates approximately symmetric distribution.".

"""
        
        elif q_num == 7:
            code += """* Descriptive statistics by City.
SORT CASES BY X6.
SPLIT FILE SEPARATE BY X6.
FREQUENCIES VARIABLES=X1 X2 
  /FORMAT=NOTABLE 
  /STATISTICS=MEAN MEDIAN MODE MIN MAX RANGE VAR STDDEV SKEW.
SPLIT FILE OFF.

"""
        
        elif q_num == 8:
            code += """* Descriptive statistics by Debit Card status.
SORT CASES BY X4.
SPLIT FILE SEPARATE BY X4.
FREQUENCIES VARIABLES=X1 X2 
  /FORMAT=NOTABLE 
  /STATISTICS=MEAN MEDIAN MODE MIN MAX RANGE VAR STDDEV SKEW.
SPLIT FILE OFF.

"""
        
        elif q_num == 9:
            code += """* Bar chart of average balance by city.
GRAPH /BAR(SIMPLE)=MEAN(X1) BY X6
  /TITLE="Average Account Balance by City"
  /FOOTNOTE="Higher average balances indicate wealthier locations".

"""
        
        elif q_num == 10:
            code += """* Bar chart of maximum ATM transactions by debit card status.
GRAPH /BAR(SIMPLE)=MAX(X2) BY X4
  /TITLE="Maximum ATM Transactions by Debit Card Status"
  /FOOTNOTE="Debit card holders show higher transaction capacity".

"""
        
        elif q_num == 11:
            code += """* Grouped bar chart for interaction analysis.
GRAPH /BAR(GROUPED)=MEAN(X1) BY X6 BY X4
  /TITLE="Average Balance by City and Debit Card Status"
  /FOOTNOTE="Interaction between location and card ownership".

"""
        
        elif q_num == 12:
            code += """* Percentage bar chart for interest recipients.
GRAPH /BAR(SIMPLE)=PCT BY X5
  /TITLE="Percentage of Interest Receivers vs Non-Receivers"
  /FOOTNOTE="Shows market penetration of interest-bearing accounts".

"""
        
        elif q_num == 13:
            code += """* Pie chart for market share visualization.
GRAPH /PIE=PCT BY X5
  /TITLE="Market Share: Customers Receiving Interest (%)"
  /FOOTNOTE="Proportion of customers who receive interest payments".

"""
        
        elif q_num == 14:
            code += """* Confidence intervals for mean account balance.
EXAMINE VARIABLES=X1 
  /STATISTICS DESCRIPTIVES 
  /CINTERVAL 95 
  /PLOT NONE.
EXAMINE VARIABLES=X1 
  /STATISTICS DESCRIPTIVES 
  /CINTERVAL 99 
  /PLOT NONE.
ECHO "INTERPRETATION: Wider 99% CI provides more confidence but less precision".

"""
        
        elif q_num == 15:
            code += """* Normality test and rule application.
EXAMINE VARIABLES=X1 
  /PLOT NPPLOT 
  /STATISTICS DESCRIPTIVES
  /MISSING LISTWISE.
ECHO "RULE: If Shapiro-Wilk Sig > 0.05, distribution is normal - apply Empirical Rule.".
ECHO "If Sig < 0.05, distribution is non-normal - use Chebyshev's Theorem.".

"""
        
        elif q_num == 16:
            code += """* Boxplot for outlier detection.
EXAMINE VARIABLES=X1 
  /PLOT BOXPLOT 
  /STATISTICS DESCRIPTIVES
  /MISSING LISTWISE.
ECHO "ANALYSIS: Points outside whiskers (1.5*IQR) are potential outliers.".
ECHO "Extreme outliers (3*IQR) are marked with asterisks (*).".

"""
        
        else:
            code += f"* Analysis for question {q_num}: {clean_question}\n"
            code += "* Add custom SPSS syntax here.\n\n"
        
        return code
    
    def create_download_link(self, content, filename):
        """Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· ØªØ­Ù…ÙŠÙ„ Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"""
        try:
            b64 = base64.b64encode(content.encode('utf-8')).decode()
            return f'<a href="data:file/txt;base64,{b64}" download="{filename}" style="text-decoration:none;">ğŸ“¥ ØªØ­Ù…ÙŠÙ„ {filename}</a>'
        except:
            return f'âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„'

def main():
    st.set_page_config(
        page_title="SPSS Syntax Generator - Professional Edition",
        page_icon="ğŸ“Š",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    # Custom CSS for better appearance
    st.markdown("""
    <style>
    .main-header {
        background: linear-gradient(90deg, #4e73df 0%, #224abe 100%);
        padding: 20px;
        border-radius: 10px;
        color: white;
        margin-bottom: 20px;
    }
    .stButton > button {
        background-color: #4e73df;
        color: white;
        font-weight: bold;
        border: none;
        padding: 10px 24px;
        border-radius: 5px;
        transition: all 0.3s;
    }
    .stButton > button:hover {
        background-color: #224abe;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    </style>
    """, unsafe_allow_html=True)
    
    st.markdown('<div class="main-header"><h1>ğŸ“Š Ù…ÙˆÙ„Ø¯ Ø£ÙƒÙˆØ§Ø¯ SPSS Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ</h1><p>ÙŠÙˆÙ„Ø¯ Ø£ÙƒÙˆØ§Ø¯ SPSS Ù…Ø·Ø§Ø¨Ù‚Ø© ØªÙ…Ø§Ù…Ø§Ù‹ Ù„Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø£ÙƒØ§Ø¯ÙŠÙ…ÙŠØ© Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</p></div>', unsafe_allow_html=True)
    
    generator = PerfectSPSSGenerator()
    
    # Sidebar with instructions
    with st.sidebar:
        st.header("ğŸ“Œ ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…")
        st.markdown("""
        1. **Ø±ÙØ¹ Ù…Ù„Ù Excel**: ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (X1, X2, ...)
        2. **Ø±ÙØ¹ Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø¦Ù„Ø©**: Ù†Øµ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø±Ù‚Ù…Ø©
        3. **ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯**: Ø¶ØºØ· Ø§Ù„Ø²Ø± Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙƒÙˆØ¯ SPSS
        4. **ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù**: Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ù„Ù .sps
        
        **Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**
        - X1: Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨
        - X2: Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø§Ù„ØµØ±Ø§Ù Ø§Ù„Ø¢Ù„ÙŠ
        - X3: Ø®Ø¯Ù…Ø§Øª Ø£Ø®Ø±Ù‰
        - X4: Ø­Ø§Ù…Ù„ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø®ØµÙ…
        - X5: Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„ÙÙˆØ§Ø¦Ø¯
        - X6: Ø§Ù„Ù…ÙˆÙ‚Ø¹
        """)
        
        st.info("ğŸ“Š **Ø§Ù„Ø¥ØµØ¯Ø§Ø±**: 2.0.0 | **Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«**: ÙØ¨Ø±Ø§ÙŠØ± 2025")
    
    # Main content area
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("ğŸ“ Ø±ÙØ¹ Ù…Ù„Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
        excel_file = st.file_uploader(
            "Ø§Ø®ØªØ± Ù…Ù„Ù Excel",
            type=['xls', 'xlsx', 'xlsm'],
            help="ÙŠØ¯Ø¹Ù… Ù…Ù„ÙØ§Øª Excel Ø¨ØµÙŠØº xls, xlsx, xlsm"
        )
        
        if excel_file:
            st.success(f"âœ… ØªÙ… Ø±ÙØ¹: {excel_file.name}")
    
    with col2:
        st.subheader("ğŸ“ Ø±ÙØ¹ Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø¦Ù„Ø©")
        questions_file = st.file_uploader(
            "Ø§Ø®ØªØ± Ù…Ù„Ù Ø§Ù„Ø£Ø³Ø¦Ù„Ø©",
            type=['txt', 'doc', 'docx', 'rtf'],
            help="ÙŠØ¯Ø¹Ù… Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ÙˆØ§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©"
        )
        
        if questions_file:
            st.success(f"âœ… ØªÙ… Ø±ÙØ¹: {questions_file.name}")
    
    # Process files
    if excel_file and questions_file:
        try:
            # Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ø¯Ø¹Ù… Ø£ÙØ¶Ù„ Ù„Ù„ØµÙŠØº
            try:
                df = pd.read_excel(excel_file, engine='openpyxl')
            except:
                df = pd.read_excel(excel_file)
            
            # Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„ØªØ±Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
            questions_content = questions_file.getvalue()
            
            # Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙƒ Ø§Ù„ØªØ±Ù…ÙŠØ²
            try:
                questions_text = questions_content.decode('utf-8')
            except:
                try:
                    questions_text = questions_content.decode('cp1256')  # Arabic Windows
                except:
                    questions_text = questions_content.decode('latin-1', errors='ignore')
            
            questions = generator.parse_questions(questions_text)
            
            if not questions:
                st.warning("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù.")
                return
            
            # Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
            col_stats1, col_stats2, col_stats3 = st.columns(3)
            with col_stats1:
                st.metric("Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…ÙƒØªØ´ÙØ©", len(questions))
            with col_stats2:
                st.metric("Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©", min(len(questions), 16))
            with col_stats3:
                st.metric("Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", len(df.columns))
            
            # Ø¹Ø±Ø¶ Ø¹ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
            with st.expander("ğŸ“‹ Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù…Ø­Ù„Ù„Ø©", expanded=False):
                for i, q in enumerate(questions[:8], 1):
                    st.write(f"**{i}.** {q[:100]}..." if len(q) > 100 else f"**{i}.** {q}")
                if len(questions) > 8:
                    st.write(f"... Ùˆ{len(questions)-8} Ø£Ø³Ø¦Ù„Ø© Ø£Ø®Ø±Ù‰")
            
            # Preview data
            with st.expander("ğŸ” Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", expanded=False):
                st.dataframe(df.head(10), use_container_width=True)
                
                # Show data types
                col_types = pd.DataFrame({
                    'Column': df.columns,
                    'Type': df.dtypes.astype(str),
                    'Non-Null': df.count().values,
                    'Unique': [df[col].nunique() for col in df.columns]
                })
                st.dataframe(col_types, use_container_width=True)
            
            # Generate button
            col_btn1, col_btn2, col_btn3 = st.columns([1, 2, 1])
            with col_btn2:
                generate_button = st.button(
                    "ğŸ”„ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ SPSS Ù…ØªÙ‚Ø¯Ù…",
                    type="primary",
                    use_container_width=True
                )
            
            if generate_button:
                with st.spinner("âš™ï¸ Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ SPSS Ø§Ù„Ù…ØªÙ‚Ø¯Ù…..."):
                    spss_code = generator.generate_dataset1_code(questions, df)
                    
                    # Display code
                    st.subheader("ğŸ“‹ ÙƒÙˆØ¯ SPSS Ø§Ù„Ù…ØªÙ‚Ø¯Ù…")
                    
                    # Tabs for different views
                    tab1, tab2, tab3 = st.tabs(["Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„", "Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø®ØªØµØ±Ø©", "Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙƒÙˆØ¯"])
                    
                    with tab1:
                        st.code(spss_code, language='spss', line_numbers=True)
                    
                    with tab2:
                        preview_lines = spss_code.split('\n')[:50]
                        st.code('\n'.join(preview_lines) + "\n... (ÙŠØªØ¨Ø¹)", language='spss')
                    
                    with tab3:
                        col_info1, col_info2 = st.columns(2)
                        with col_info1:
                            st.markdown("""
                            **Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„ÙƒÙˆØ¯:**
                            - âœ… ØªØ¹Ø±ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª
                            - âœ… ØªØ±Ù…ÙŠØ² Ø§Ù„ÙØ¦Ø§Øª
                            - âœ… Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØµÙÙŠØ©
                            - âœ… Ø±Ø³ÙˆÙ… Ø¨ÙŠØ§Ù†ÙŠØ©
                            - âœ… Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø·Ø¨ÙŠØ¹ÙŠØ©
                            - âœ… ÙƒØ´Ù Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø©
                            """)
                        
                        with col_info2:
                            st.markdown("""
                            **Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:**
                            - ğŸ“Š 16 Ø³Ø¤Ø§Ù„ Ø£ÙƒØ§Ø¯ÙŠÙ…ÙŠ
                            - ğŸ’¬ ØªØ¹Ù„ÙŠÙ‚Ø§Øª ØªÙØ³ÙŠØ±ÙŠØ©
                            - ğŸ” ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù…
                            - ğŸ¯ ØªÙˆØ§ÙÙ‚ Ù…Ø¹ SPSS v25+
                            """)
                    
                    # Download button
                    st.markdown("<br>", unsafe_allow_html=True)
                    col_dl1, col_dl2, col_dl3 = st.columns([1, 2, 1])
                    with col_dl2:
                        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                        filename = f"SPSS_Analysis_{timestamp}.sps"
                        st.markdown(
                            generator.create_download_link(spss_code, filename),
                            unsafe_allow_html=True
                        )
                    
                    # Export options
                    with st.expander("ğŸ“¤ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªØµØ¯ÙŠØ± Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©"):
                        export_format = st.radio(
                            "Ø§Ø®ØªØ± ØµÙŠØºØ© Ø§Ù„ØªØµØ¯ÙŠØ±:",
                            ["SPSS Syntax (.sps)", "Plain Text (.txt)", "Documentation (.md)"],
                            horizontal=True
                        )
                        
                        if export_format == "SPSS Syntax (.sps)":
                            export_code = spss_code
                            export_name = f"SPSS_Analysis_{timestamp}.sps"
                        elif export_format == "Plain Text (.txt)":
                            export_code = spss_code
                            export_name = f"SPSS_Analysis_{timestamp}.txt"
                        else:
                            export_code = f"""# SPSS Analysis Documentation
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Questions: {len(questions)}

## Code Summary
{spss_code[:1000]}...

## Variables Used
- X1: Account Balance
- X2: ATM Transactions
- X3: Other Services
- X4: Debit Card Holder
- X5: Interest Received
- X6: City Location
"""
                            export_name = f"SPSS_Documentation_{timestamp}.md"
                        
                        st.markdown(
                            generator.create_download_link(export_code, export_name),
                            unsafe_allow_html=True
                        )
        
        except Exception as e:
            st.error(f"âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {str(e)}")
            st.exception(e)  # Show detailed error for debugging
    
    else:
        # Welcome interface
        st.info("""
        ### ğŸ‘‹ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…ÙˆÙ„Ø¯ Ø£ÙƒÙˆØ§Ø¯ SPSS
        
        **Ù„Ù„Ø¨Ø¯Ø¡ØŒ ÙŠØ±Ø¬Ù‰ Ø§ØªØ¨Ø§Ø¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:**
        1. Ø§Ø±ÙØ¹ Ù…Ù„Ù Excel Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ
        2. Ø§Ø±ÙØ¹ Ù…Ù„Ù Ù†ØµÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ø¨Ø­Ø«
        3. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ SPSS
        
        **Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…:**
        - âœ¨ ØªÙˆÙ„ÙŠØ¯ Ø£ÙƒÙˆØ§Ø¯ Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„ØªØ´ØºÙŠÙ„ Ù…Ø¨Ø§Ø´Ø±Ø©
        - ğŸ“Š Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠ
        - ğŸ”§ ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø¥ØµØ¯Ø§Ø±Ø§Øª SPSS
        - ğŸŒ Ø¯Ø¹Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
        """)
        
        # Show sample
        with st.expander("ğŸ¯ Ø¹Ø±Ø¶ Ù†Ù…ÙˆØ°Ø¬ Ù„Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…ÙˆÙ„Ø¯"):
            st.code("""* Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ ÙƒÙˆØ¯ SPSS Ø§Ù„Ø°ÙŠ Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯Ù‡:
* -------------------------------------------------------------------------.
TITLE "QUESTION 1: Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„ØªÙƒØ±Ø§Ø±ÙŠ Ù„Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ÙØ¦ÙˆÙŠØ©".
* -------------------------------------------------------------------------.
FREQUENCIES VARIABLES=X4 X5 X6 /ORDER=ANALYSIS.
ECHO "INTERPRETATION: Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙŠÙˆØ¶Ø­ ØªÙˆØ²ÙŠØ¹ ..."

* -------------------------------------------------------------------------.
TITLE "QUESTION 2: ØªÙˆØ²ÙŠØ¹ Ø±ØµÙŠØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨".
* -------------------------------------------------------------------------.
RECODE X1 (0 thru 500=1) (500.01 thru 1000=2) ... INTO X1_Classes.
FREQUENCIES VARIABLES=X1_Classes /FORMAT=AVALUE.
""", language='spss')

if __name__ == "__main__":
    main()
